# Как устроен проект Bank Management API

## Что это за проект?

Это веб-приложение для управления банковскими операциями через REST API. Пользователи могут регистрироваться, создавать счета, переводить деньги, управлять картами и т.д.

---

## Архитектура: слоистое приложение

Проект построен по многослойной архитектуре. Каждый слой отвечает за свою задачу.

```
┌─────────────────────────────────────┐
│   Клиент (Postman, браузер, app)    │
└──────────────┬──────────────────────┘
               │ HTTP запросы (JSON)
               ↓
┌─────────────────────────────────────┐
│  1. Controller (Контроллеры)        │  ← Принимает HTTP запросы
│     - CustomerController            │     Маршрутизация
│     - AccountController             │
│     - TransactionController         │
└──────────────┬──────────────────────┘
               │ Вызывает методы сервиса
               ↓
┌─────────────────────────────────────┐
│  2. Service (Сервисы)               │  ← Бизнес-логика
│     - CustomerService               │     Правила работы
│     - AccountService                │
│     - TransactionService            │
└──────────────┬──────────────────────┘
               │ Работает с репозиториями
               ↓
┌─────────────────────────────────────┐
│  3. Repository (Репозитории)        │  ← Доступ к данным
│     - CustomerRepository            │     SQL запросы
│     - AccountRepository             │
│     - TransactionRepository         │
└──────────────┬──────────────────────┘
               │ JPA/Hibernate
               ↓
┌─────────────────────────────────────┐
│  4. Database (База данных)          │  ← Хранение данных
│     PostgreSQL / H2                 │
└─────────────────────────────────────┘
```

---

## Как работает один запрос (на примере перевода денег)

### 1. Клиент отправляет запрос

```http
POST /api/transactions
Authorization: Bearer eyJhbGciOiJIUzI1NiJ9...
Content-Type: application/json

{
  "fromAccountId": 1,
  "toAccountId": 2,
  "amount": 1000.00,
  "currency": "RUB"
}
```

### 2. Фильтр безопасности (JwtAuthFilter)

- Извлекает токен из заголовка `Authorization`
- Проверяет его валидность
- Извлекает данные пользователя (ID, роль) и сохраняет в SecurityContext
- Если токен невалиден — запрос отклоняется

### 3. Controller получает запрос

```java
@PostMapping
public ResponseEntity<TransactionDto> transfer(@RequestBody CreateTransactionRequest req) {
    TransactionDto saved = transactionService.transfer(req);
    return ResponseEntity.ok(saved);
}
```

Контроллер:
- Принимает JSON и преобразует в объект `CreateTransactionRequest`
- Вызывает метод сервиса
- Возвращает ответ в формате JSON

### 4. Service выполняет бизнес-логику

```java
@Transactional  // ← ВАЖНО: вся операция атомарна
public TransactionDto transfer(CreateTransactionRequest req) {
    // 1. Находим счета в БД
    Account fromAccount = accountRepository.findById(...);
    Account toAccount = accountRepository.findById(...);
    
    // 2. Проверяем статус счетов (должны быть ACTIVE)
    // 3. Проверяем валюту (должна совпадать)
    // 4. Проверяем достаточность средств
    if (!fromAccount.canWithdraw(amount)) {
        // Создаем FAILED транзакцию
    }
    
    // 5. Списываем деньги
    fromAccount.setBalance(fromAccount.getBalance().subtract(amount));
    toAccount.setBalance(toAccount.getBalance().add(amount));
    
    // 6. Сохраняем изменения
    accountRepository.save(fromAccount);
    accountRepository.save(toAccount);
    
    // 7. Создаем запись о транзакции
    Transaction transaction = new Transaction(...);
    return transactionRepository.save(transaction);
}
```

**Почему `@Transactional` важно:**
- Все шаги выполняются в одной транзакции БД
- Если что-то пошло не так — все изменения откатываются
- Гарантируется консистентность данных

### 5. Repository сохраняет в БД

```java
public interface TransactionRepository extends JpaRepository<Transaction, Long> {
    // Spring Data JPA автоматически создает методы:
    // save(), findById(), findAll(), delete() и т.д.
}
```

Spring Data JPA генерирует SQL-запросы автоматически.

### 6. Ответ возвращается клиенту

```json
{
  "id": 123,
  "fromAccountId": 1,
  "toAccountId": 2,
  "amount": 1000.00,
  "currency": "RUB",
  "status": "COMPLETED",
  "timestamp": "2024-01-15T10:30:00"
}
```

---

## Основные компоненты проекта

### 1. Model (Модели) — структура данных

Определяют, какие данные хранятся:

```java
@Entity
public class Account {
    private Long id;
    private String accountNumber;
    private Customer customer;  // Связь "многие к одному"
    private BigDecimal balance;
    private AccountType type;   // DEBIT или CREDIT
    private BigDecimal creditLimit;
    
    // Методы бизнес-логики
    public boolean canWithdraw(BigDecimal amount) {
        // Проверка возможности списания
    }
}
```

`@Entity` означает, что класс — таблица в БД.

### 2. DTO (Data Transfer Objects) — данные для API

Объекты для обмена между клиентом и сервером:

```java
public class CreateTransactionRequest {
    private Long fromAccountId;
    private Long toAccountId;
    private BigDecimal amount;
    private String currency;
}
```

**Зачем нужны:**
- Модели содержат лишние поля (например, `@Entity` аннотации)
- DTO показывает, какие данные ожидает/возвращает API
- Можно менять внутреннюю модель без изменения API

### 3. Security (Безопасность)

#### JWT (JSON Web Token)

Токены вместо сессий:
- **Access Token** — короткий (15 минут), используется в каждом запросе
- **Refresh Token** — долгий (14 дней), для обновления Access Token

**Как это работает:**
1. Пользователь логинится → получает оба токена
2. В каждом запросе отправляет Access Token в заголовке `Authorization: Bearer <token>`
3. Когда Access Token истекает → использует Refresh Token для получения нового

#### Роли пользователей

- **CLIENT** — обычный клиент банка
- **ADMIN** — администратор (может блокировать счета/карты)

Проверка в `SecurityConfig`:
```java
.requestMatchers("/api/accounts/*/block").hasAuthority("ADMIN")
```

### 4. Exception Handling (Обработка ошибок)

`GlobalExceptionHandler` перехватывает исключения и возвращает понятные JSON-ответы:

```java
@ExceptionHandler(NotFoundException.class)
public ResponseEntity<Map<String, Object>> handleNotFound(NotFoundException ex) {
    return ResponseEntity.status(404).body(...);
}
```

Если где-то выброшено `NotFoundException`, клиент получит:
```json
{
  "status": 404,
  "error": "Not Found",
  "message": "Account with id=999 not found"
}
```

---

## Как запускается приложение

### 1. Точка входа — `BankApplication.java`

```java
@SpringBootApplication
public class BankApplication {
    public static void main(String[] args) {
        SpringApplication.run(BankApplication.class, args);
    }
}
```

`@SpringBootApplication` включает:
- Автоконфигурацию
- Сканирование компонентов
- Встроенный веб-сервер (Tomcat)

### 2. Spring создает компоненты

Spring сканирует пакеты и создает экземпляры (бины):
- `@Controller` → контроллеры
- `@Service` → сервисы
- `@Repository` → репозитории
- `@Configuration` → конфигурации

### 3. Подключение к БД

При старте Spring:
- Подключается к PostgreSQL (или H2)
- Запускает Flyway миграции (создает таблицы)
- Проверяет, что структура соответствует моделям

---

## Важные концепции

### Dependency Injection (Внедрение зависимостей)

```java
@RequiredArgsConstructor  // Lombok создает конструктор
public class TransactionService {
    private final TransactionRepository transactionRepository;
    private final AccountRepository accountRepository;
    
    // Spring автоматически передает репозитории в конструктор
}
```

Вместо `new TransactionRepository()` Spring сам передает готовые объекты.

### Аннотации Spring

- `@RestController` — класс обрабатывает HTTP-запросы
- `@RequestMapping("/api/transactions")` — базовый путь для всех методов
- `@PostMapping` — метод обрабатывает POST-запросы
- `@GetMapping` — метод обрабатывает GET-запросы
- `@Service` — класс содержит бизнес-логику
- `@Transactional` — метод выполняется в транзакции БД
- `@Entity` — класс представляет таблицу в БД

### Типы счетов и их логика

- **Дебетовый (DEBIT)**: баланс не может быть отрицательным
- **Кредитный (CREDIT)**: баланс может уйти в минус до `creditLimit`

В методе `canWithdraw()`:
```java
if (type == AccountType.DEBIT) {
    return balance.compareTo(amount) >= 0;  // Баланс >= суммы
} else { // CREDIT
    BigDecimal available = balance.add(creditLimit);
    return available.compareTo(amount) >= 0;  // Баланс + лимит >= суммы
}
```

---

## Резюме: полный цикл

1. **Клиент** → HTTP-запрос с JWT токеном
2. **JwtAuthFilter** → проверяет токен
3. **Controller** → принимает запрос, вызывает Service
4. **Service** → бизнес-логика, проверки
5. **Repository** → работа с БД
6. **Database** → сохранение данных
7. **Ответ** идет обратно через все слои
8. **Клиент** получает JSON-ответ

Каждый слой отвечает за свою задачу, что упрощает поддержку и тестирование.

---

Это базовая структура проекта. Если нужны детали по конкретной части — можно разобрать подробнее!

